.. py:method:: Opti.derivative_of(variable, with_respect_to, derivative_init_guess, derivative_scale = None, method = 'trapezoidal', explicit = False, _stacklevel = 1)

   Returns a quantity that is either defined or constrained to be a derivative of an existing variable.

   For example:

   >>> opti = Opti()
   >>> position = opti.variable(init_guess=0, n_vars=100)
   >>> time = np.linspace(0, 1, 100)
   >>> velocity = opti.derivative_of(position, with_respect_to=time)
   >>> acceleration = opti.derivative_of(velocity, with_respect_to=time)

   :param variable: The variable or quantity that you are taking the derivative of. The "numerator" of the
   :param derivative:
   :param in colloquial parlance.:
   :param with_respect_to: The variable or quantity that you are taking the derivative with respect to. The
   :param "denominator" of the derivative: In a typical example case, this `with_respect_to` parameter would be time. Please make sure that the
                                           value of this parameter is monotonically increasing, otherwise you may get nonsensical answers.
   :param in colloquial parlance.: In a typical example case, this `with_respect_to` parameter would be time. Please make sure that the
                                   value of this parameter is monotonically increasing, otherwise you may get nonsensical answers.
   :param derivative_init_guess: Initial guess for the value of the derivative. Should be either a float (in which
   :param case the initial guess will be a vector equal to this value) or a vector of initial guesses with the same:
   :param length as `variable`. For more info:
   :param look at the docstring of opti.variable()'s `init_guess` parameter.:
   :param derivative_scale: Scale factor for the value of the derivative. For more info, look at the docstring of
   :param opti.variable()'s `scale` parameter.:
   :param method: The type of integrator to use to define this derivative. Options are:

                  * "forward euler" - a first-order-accurate forward Euler method

                      Citation: https://en.wikipedia.org/wiki/Euler_method

                  * "backwards euler" - a first-order-accurate backwards Euler method

                      Citation: https://en.wikipedia.org/wiki/Backward_Euler_method

                  * "midpoint" or "trapezoid" - a second-order-accurate midpoint method

                      Citation: https://en.wikipedia.org/wiki/Midpoint_method

                  * "simpson" - Simpson's rule for integration

                      Citation: https://en.wikipedia.org/wiki/Simpson%27s_rule

                  * "runge-kutta" or "rk4" - a fourth-order-accurate Runge-Kutta method. I suppose that technically,
                  "forward euler", "backward euler", and "midpoint" are all (lower-order) Runge-Kutta methods...

                      Citation: https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#The_Runge%E2%80%93Kutta_method

                  * "runge-kutta-3/8" - A modified version of the Runge-Kutta 4 proposed by Kutta in 1901. Also
                  fourth-order-accurate, but all of the error coefficients are smaller than they are in the standard
                  Runge-Kutta 4 method. The downside is that more floating point operations are required per timestep,
                  as the Butcher tableau is more dense (i.e. not banded).

                      Citation: Kutta, Martin (1901), "Beitrag zur näherungsweisen Integration totaler
                      Differentialgleichungen", Zeitschrift für Mathematik und Physik, 46: 435–453
   :param explicit: If true, returns an explicit derivative rather than an implicit one. In other words,
   :param this *defines* the output to be a derivative of the input rather than *constraining* the output to the a:
   :param derivative of the input.: Explicit derivatives result in smaller, denser systems of equations that are more akin to
                                    shooting-type methods. Implicit derivatives result in larger, sparser systems of equations that are
                                    more akin to collocation methods. Explicit derivatives are better for simple, stable systems with few
                                    states, while implicit derivatives are better for complex, potentially-unstable systems with many
                                    states.

                                    # TODO implement explicit
   :param _stacklevel: Optional and advanced, purely used for debugging. Allows users to correctly track where
   :param constraints are declared in the event that they are subclassing `aerosandbox.Opti`. Modifies the:
   :param stacklevel of the declaration tracked:
   :param which is then presented using:
   :param `aerosandbox.Opti.variable_declaration:
   :type `aerosandbox.Opti.variable_declaration: )` and `aerosandbox.Opti.constraint_declaration(

   Returns: A vector consisting of the derivative of the parameter `variable` with respect to `with_respect_to`.



